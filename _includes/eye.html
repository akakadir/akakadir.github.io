<div class="gothic-eye-container"></div>

<style>
.gothic-eye-container {
    width: 50px;
    height: 50px;
    display: inline-block;
    position: relative;
    margin: 0;
    padding: 0;
    line-height: 0;
}

.gothic-eye-container canvas {
    filter: drop-shadow(0 0 8px rgba(139, 0, 0, 0.8));
    display: block;
    margin: 0;
    padding: 0;
}
</style>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
(function() {
    const container = document.querySelector('.gothic-eye-container');
    const canvas = document.createElement('canvas');
    container.appendChild(canvas);
    
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(40, 1, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ 
        canvas: canvas, 
        antialias: true, 
        alpha: true 
    });
    
    renderer.setSize(50, 50);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.setClearColor(0x000000, 0);
    
    camera.position.set(0, 0, 7);
    
    const ambientLight = new THREE.AmbientLight(0x330000, 0.8);
    scene.add(ambientLight);
    
    const bloodLight1 = new THREE.PointLight(0xff0000, 1.5, 20);
    bloodLight1.position.set(4, 3, 8);
    bloodLight1.castShadow = true;
    scene.add(bloodLight1);
    
    const bloodLight2 = new THREE.PointLight(0x8b0000, 1.2, 15);
    bloodLight2.position.set(-4, -2, 6);
    scene.add(bloodLight2);
    
    const darkLight = new THREE.DirectionalLight(0x330000, 0.5);
    darkLight.position.set(0, 5, 5);
    scene.add(darkLight);
    
    const eyeGroup = new THREE.Group();
    scene.add(eyeGroup);
    
    const eyeballGeo = new THREE.SphereGeometry(1.8, 128, 128);
    
    const scleraCanvas = document.createElement('canvas');
    scleraCanvas.width = 2048;
    scleraCanvas.height = 1024;
    const sCtx = scleraCanvas.getContext('2d');
    
    const baseGrad = sCtx.createRadialGradient(1024, 512, 0, 1024, 512, 1024);
    baseGrad.addColorStop(0, '#fef5f5');
    baseGrad.addColorStop(0.3, '#f5e8e8');
    baseGrad.addColorStop(0.6, '#ead8d8');
    baseGrad.addColorStop(1, '#d8c0c0');
    sCtx.fillStyle = baseGrad;
    sCtx.fillRect(0, 0, 2048, 1024);
    
    function drawBloodVessel(x, y, angle, length, width, opacity, branches) {
        let posX = x;
        let posY = y;
        let currentAngle = angle;
        
        for (let i = 0; i < length; i++) {
            const fade = 1 - (i / length) * 0.4;
            const currentWidth = width * fade;
            const alpha = opacity * fade;
            
            const red = 139 + Math.random() * 40;
            const green = Math.random() * 20;
            const blue = Math.random() * 20;
            
            sCtx.strokeStyle = `rgba(${red}, ${green}, ${blue}, ${alpha})`;
            sCtx.lineWidth = currentWidth;
            sCtx.lineCap = 'round';
            
            sCtx.beginPath();
            sCtx.moveTo(posX, posY);
            
            currentAngle += (Math.random() - 0.5) * 0.25;
            const step = 3 + Math.random() * 2;
            posX += Math.cos(currentAngle) * step;
            posY += Math.sin(currentAngle) * step;
            
            sCtx.lineTo(posX, posY);
            sCtx.stroke();
            
            if (i % 12 === 0 && branches > 0 && Math.random() > 0.5) {
                const branchAngle = currentAngle + (Math.random() - 0.5) * Math.PI / 2;
                drawBloodVessel(posX, posY, branchAngle, length * 0.6, width * 0.7, opacity * 0.8, branches - 1);
            }
        }
    }
    
    const mainVessels = 16;
    for (let i = 0; i < mainVessels; i++) {
        const angle = (i / mainVessels) * Math.PI * 2;
        const startRadius = 300 + Math.random() * 150;
        const x = 1024 + Math.cos(angle) * startRadius;
        const y = 512 + Math.sin(angle) * startRadius;
        const targetAngle = Math.atan2(512 - y, 1024 - x) + (Math.random() - 0.5) * 0.3;
        
        drawBloodVessel(x, y, targetAngle, 140 + Math.random() * 60, 3.5 + Math.random() * 2, 0.6, 3);
    }
    
    for (let i = 0; i < 60; i++) {
        const angle = Math.random() * Math.PI * 2;
        const radius = 350 + Math.random() * 300;
        const x = 1024 + Math.cos(angle) * radius;
        const y = 512 + Math.sin(angle) * radius;
        const targetAngle = Math.atan2(512 - y, 1024 - x) + (Math.random() - 0.5);
        
        drawBloodVessel(x, y, targetAngle, 50 + Math.random() * 40, 1.5 + Math.random(), 0.4, 1);
    }
    
    for (let i = 0; i < 25; i++) {
        const angle = Math.random() * Math.PI * 2;
        const radius = 250 + Math.random() * 350;
        const x = 1024 + Math.cos(angle) * radius;
        const y = 512 + Math.sin(angle) * radius;
        const size = 25 + Math.random() * 50;
        
        const bloodPool = sCtx.createRadialGradient(x, y, 0, x, y, size);
        bloodPool.addColorStop(0, 'rgba(139, 0, 0, 0.5)');
        bloodPool.addColorStop(0.4, 'rgba(139, 0, 0, 0.3)');
        bloodPool.addColorStop(0.7, 'rgba(100, 0, 0, 0.15)');
        bloodPool.addColorStop(1, 'rgba(80, 0, 0, 0)');
        
        sCtx.fillStyle = bloodPool;
        sCtx.beginPath();
        sCtx.arc(x, y, size, 0, Math.PI * 2);
        sCtx.fill();
    }
    
    for (let i = 0; i < 100; i++) {
        sCtx.fillStyle = `rgba(139, 0, 0, ${0.2 + Math.random() * 0.3})`;
        const x = Math.random() * 2048;
        const y = Math.random() * 1024;
        sCtx.beginPath();
        sCtx.arc(x, y, 1 + Math.random() * 3, 0, Math.PI * 2);
        sCtx.fill();
    }
    
    const scleraTexture = new THREE.CanvasTexture(scleraCanvas);
    scleraTexture.needsUpdate = true;
    
    const eyeballMat = new THREE.MeshStandardMaterial({
        map: scleraTexture,
        roughness: 0.6,
        metalness: 0,
        emissive: new THREE.Color(0x330000),
        emissiveIntensity: 0.1
    });
    
    const eyeball = new THREE.Mesh(eyeballGeo, eyeballMat);
    eyeball.castShadow = true;
    eyeball.receiveShadow = true;
    eyeGroup.add(eyeball);
    
    const irisGroup = new THREE.Group();
    eyeGroup.add(irisGroup);
    
    const irisGeo = new THREE.CircleGeometry(0.75, 128);
    const irisCanvas = document.createElement('canvas');
    irisCanvas.width = 1024;
    irisCanvas.height = 1024;
    const iCtx = irisCanvas.getContext('2d');
    
    const irisGrad = iCtx.createRadialGradient(512, 512, 0, 512, 512, 512);
    irisGrad.addColorStop(0, '#6b3410');
    irisGrad.addColorStop(0.15, '#5a2210');
    irisGrad.addColorStop(0.35, '#4a1510');
    irisGrad.addColorStop(0.6, '#3a0a08');
    irisGrad.addColorStop(0.85, '#2a0505');
    irisGrad.addColorStop(1, '#1a0303');
    iCtx.fillStyle = irisGrad;
    iCtx.fillRect(0, 0, 1024, 1024);
    
    for (let i = 0; i < 300; i++) {
        const angle = (i / 300) * Math.PI * 2;
        const wobble = Math.sin(i * 0.3) * 15;
        const startRadius = 100 + Math.random() * 30;
        const endRadius = 480 + wobble;
        
        const gradient = iCtx.createLinearGradient(
            512 + Math.cos(angle) * startRadius,
            512 + Math.sin(angle) * startRadius,
            512 + Math.cos(angle) * endRadius,
            512 + Math.sin(angle) * endRadius
        );
        
        gradient.addColorStop(0, `rgba(139, 50, 20, ${0.4 + Math.random() * 0.3})`);
        gradient.addColorStop(0.5, `rgba(100, 30, 15, ${0.3 + Math.random() * 0.2})`);
        gradient.addColorStop(1, `rgba(60, 10, 5, ${0.2 + Math.random() * 0.2})`);
        
        iCtx.strokeStyle = gradient;
        iCtx.lineWidth = 1 + Math.random() * 1.5;
        iCtx.beginPath();
        iCtx.moveTo(512, 512);
        iCtx.lineTo(
            512 + Math.cos(angle) * endRadius,
            512 + Math.sin(angle) * endRadius
        );
        iCtx.stroke();
    }
    
    for (let r = 150; r < 500; r += 40) {
        iCtx.strokeStyle = `rgba(80, 0, 0, ${0.2 + Math.random() * 0.2})`;
        iCtx.lineWidth = 2 + Math.random() * 2;
        iCtx.beginPath();
        iCtx.arc(512, 512, r, 0, Math.PI * 2);
        iCtx.stroke();
    }
    
    for (let i = 0; i < 50; i++) {
        const angle = Math.random() * Math.PI * 2;
        const dist = 100 + Math.random() * 350;
        const x = 512 + Math.cos(angle) * dist;
        const y = 512 + Math.sin(angle) * dist;
        const size = 5 + Math.random() * 15;
        
        iCtx.fillStyle = `rgba(139, 0, 0, ${0.3 + Math.random() * 0.4})`;
        iCtx.beginPath();
        iCtx.arc(x, y, size, 0, Math.PI * 2);
        iCtx.fill();
    }
    
    const irisTexture = new THREE.CanvasTexture(irisCanvas);
    const irisMat = new THREE.MeshStandardMaterial({
        map: irisTexture,
        roughness: 0.4,
        metalness: 0.1,
        emissive: new THREE.Color(0x330000),
        emissiveIntensity: 0.3
    });
    
    const iris = new THREE.Mesh(irisGeo, irisMat);
    iris.position.z = 1.78;
    irisGroup.add(iris);
    
    const pupilGeo = new THREE.CircleGeometry(0.32, 64);
    const pupilMat = new THREE.MeshBasicMaterial({ 
        color: 0x000000,
        transparent: true,
        opacity: 1
    });
    const pupil = new THREE.Mesh(pupilGeo, pupilMat);
    pupil.position.z = 1.79;
    irisGroup.add(pupil);
    
    const innerShadowGeo = new THREE.RingGeometry(0.32, 0.35, 64);
    const innerShadowMat = new THREE.MeshBasicMaterial({
        color: 0x1a0000,
        transparent: true,
        opacity: 0.8,
        side: THREE.DoubleSide
    });
    const innerShadow = new THREE.Mesh(innerShadowGeo, innerShadowMat);
    innerShadow.position.z = 1.785;
    irisGroup.add(innerShadow);
    
    const limbusGeo = new THREE.RingGeometry(0.74, 0.78, 128);
    const limbusMat = new THREE.MeshBasicMaterial({ 
        color: 0x1a0303,
        transparent: true,
        opacity: 0.95,
        side: THREE.DoubleSide
    });
    const limbus = new THREE.Mesh(limbusGeo, limbusMat);
    limbus.position.z = 1.77;
    irisGroup.add(limbus);
    
    const corneaGeo = new THREE.SphereGeometry(1.82, 128, 128, 0, Math.PI * 2, 0, Math.PI * 0.55);
    const corneaMat = new THREE.MeshPhysicalMaterial({
        color: 0xffdddd,
        transparent: true,
        opacity: 0.15,
        roughness: 0.05,
        metalness: 0.1,
        clearcoat: 1.0,
        clearcoatRoughness: 0.05,
        reflectivity: 1,
        envMapIntensity: 1
    });
    const cornea = new THREE.Mesh(corneaGeo, corneaMat);
    eyeGroup.add(cornea);
    
    let mouseX = 0;
    let mouseY = 0;
    let targetRotX = 0;
    let targetRotY = 0;
    let currentRotX = 0;
    let currentRotY = 0;
    
    document.addEventListener('mousemove', (e) => {
        const rect = canvas.getBoundingClientRect();
        const eyeCenterX = rect.left + rect.width / 2;
        const eyeCenterY = rect.top + rect.height / 2;
        
        const dx = e.clientX - eyeCenterX;
        const dy = e.clientY - eyeCenterY;
        const angle = Math.atan2(dy, dx);
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        const maxMove = 0.3;
        const moveAmount = Math.min(distance / 200, maxMove);
        
        targetRotY = Math.cos(angle) * moveAmount;
        targetRotX = Math.sin(angle) * moveAmount;
    });
    
    let time = 0;
    function animate() {
        requestAnimationFrame(animate);
        time += 0.016;
        
        currentRotX += (targetRotX - currentRotX) * 0.06;
        currentRotY += (targetRotY - currentRotY) * 0.06;
        
        irisGroup.rotation.y = currentRotY;
        irisGroup.rotation.x = currentRotX;
        eyeball.rotation.y = currentRotY * 0.2;
        eyeball.rotation.x = currentRotX * 0.2;
        
        eyeGroup.rotation.z = Math.sin(time * 2) * 0.002;
        
        const pulse = 1 + Math.sin(time * 1.5) * 0.008;
        eyeGroup.scale.set(pulse, pulse, pulse);
        
        bloodLight1.intensity = 1.3 + Math.sin(time * 2) * 0.3;
        bloodLight2.intensity = 1.0 + Math.sin(time * 1.5 + 1) * 0.3;
        
        renderer.render(scene, camera);
    }
    
    animate();
})();
</script>